# ============================================================================
# PLATFORM DETECTION & CROSS-PLATFORM CONFIGURATION
# ============================================================================
# This module handles automatic OS detection and sets platform-specific
# variables and tool paths for cross-platform compatibility
#
# Supported Platforms:
# - macOS (Intel/Apple Silicon)
# - Linux (Ubuntu/Debian/RHEL/CentOS)
# - Windows (Native/WSL2) - planned
# ============================================================================

# Core platform detection
DETECTED_OS := $(shell uname -s 2>/dev/null || echo "Windows")
DETECTED_ARCH := $(shell uname -m 2>/dev/null || echo "unknown")

# Normalize OS names for consistent conditional logic
ifeq ($(DETECTED_OS),Darwin)
    PLATFORM_OS ?= macos
    PLATFORM_FAMILY ?= unix
else ifeq ($(DETECTED_OS),Linux)
    PLATFORM_OS ?= linux
    PLATFORM_FAMILY ?= unix
else ifeq ($(findstring CYGWIN,$(DETECTED_OS)),CYGWIN)
    PLATFORM_OS ?= windows
    PLATFORM_FAMILY ?= windows
else ifeq ($(findstring MINGW,$(DETECTED_OS)),MINGW)
    PLATFORM_OS ?= windows
    PLATFORM_FAMILY ?= windows
else ifeq ($(findstring MSYS,$(DETECTED_OS)),MSYS)
    PLATFORM_OS ?= windows
    PLATFORM_FAMILY ?= windows
else
    PLATFORM_OS ?= windows
    PLATFORM_FAMILY ?= windows
endif

# Architecture normalization (conditional assignment)
ifeq ($(DETECTED_ARCH),x86_64)
    PLATFORM_ARCH ?= x64
else ifeq ($(DETECTED_ARCH),amd64)
    PLATFORM_ARCH ?= x64
else ifeq ($(DETECTED_ARCH),arm64)
    PLATFORM_ARCH ?= arm64
else ifeq ($(DETECTED_ARCH),aarch64)
    PLATFORM_ARCH ?= arm64
else
    PLATFORM_ARCH ?= $(DETECTED_ARCH)
endif

# ============================================================================
# PLATFORM-SPECIFIC TOOL PATHS AND COMMANDS
# ============================================================================

# Shell and path configuration (conditional assignment)
ifeq ($(PLATFORM_FAMILY),unix)
    SHELL ?= /bin/bash
    PATH_SEP ?= /
    NULL_DEVICE ?= /dev/null
else
    SHELL ?= cmd.exe
    PATH_SEP ?= \ \
    NULL_DEVICE ?= nul
endif

# Python command detection (conditional assignment)
ifeq ($(PLATFORM_OS),macos)
    PYTHON_CMD ?= python3
    PIP_CMD ?= pip3
else ifeq ($(PLATFORM_OS),linux)
    PYTHON_CMD ?= python3
    PIP_CMD ?= pip3
else
    PYTHON_CMD ?= python
    PIP_CMD ?= pip
endif

# Package manager detection and configuration (conditional assignment)
ifeq ($(PLATFORM_OS),macos)
    PACKAGE_MANAGER ?= brew
    PACKAGE_INSTALL_CMD ?= $(PACKAGE_MANAGER) install
    PACKAGE_UPDATE_CMD ?= $(PACKAGE_MANAGER) update
else ifeq ($(PLATFORM_OS),linux)
    # Detect Linux distribution and package manager
    DISTRO ?= $(shell lsb_release -i -s 2>$(NULL_DEVICE) || echo "unknown")
    ifeq ($(DISTRO),Ubuntu)
        PACKAGE_MANAGER ?= apt
        PACKAGE_INSTALL_CMD ?= sudo $(PACKAGE_MANAGER) install -y
        PACKAGE_UPDATE_CMD ?= sudo $(PACKAGE_MANAGER) update
    else ifeq ($(DISTRO),Debian)
        PACKAGE_MANAGER ?= apt
        PACKAGE_INSTALL_CMD ?= sudo $(PACKAGE_MANAGER) install -y
        PACKAGE_UPDATE_CMD ?= sudo $(PACKAGE_MANAGER) update
    else ifeq ($(DISTRO),CentOS)
        PACKAGE_MANAGER ?= yum
        PACKAGE_INSTALL_CMD ?= sudo $(PACKAGE_MANAGER) install -y
        PACKAGE_UPDATE_CMD ?= sudo $(PACKAGE_MANAGER) update -y
    else ifeq ($(DISTRO),Fedora)
        PACKAGE_MANAGER ?= dnf
        PACKAGE_INSTALL_CMD ?= sudo $(PACKAGE_MANAGER) install -y
        PACKAGE_UPDATE_CMD ?= sudo $(PACKAGE_MANAGER) update -y
    else
        PACKAGE_MANAGER ?= apt
        PACKAGE_INSTALL_CMD ?= sudo $(PACKAGE_MANAGER) install -y
        PACKAGE_UPDATE_CMD ?= sudo $(PACKAGE_MANAGER) update
    endif
else
    PACKAGE_MANAGER ?= choco
    PACKAGE_INSTALL_CMD ?= $(PACKAGE_MANAGER) install -y
    PACKAGE_UPDATE_CMD ?= $(PACKAGE_MANAGER) upgrade
endif

# ============================================================================
# TOOL AVAILABILITY DETECTION
# ============================================================================

# Core development tools
HAS_PYTHON := $(shell command -v $(PYTHON_CMD) >/dev/null 2>&1 && echo "yes" || echo "no")
HAS_GIT := $(shell command -v git >/dev/null 2>&1 && echo "yes" || echo "no")
HAS_MAKE := $(shell command -v make >/dev/null 2>&1 && echo "yes" || echo "no")

# Package managers
HAS_BREW := $(shell command -v brew >/dev/null 2>&1 && echo "yes" || echo "no")
HAS_APT := $(shell command -v apt >/dev/null 2>&1 && echo "yes" || echo "no")
HAS_YUM := $(shell command -v yum >/dev/null 2>&1 && echo "yes" || echo "no")
HAS_DNF := $(shell command -v dnf >/dev/null 2>&1 && echo "yes" || echo "no")
HAS_CHOCO := $(shell command -v choco >/dev/null 2>&1 && echo "yes" || echo "no")

# Package manager command paths
BREW_CMD := $(shell command -v brew 2>/dev/null || echo "brew")
APT_CMD := $(shell command -v apt 2>/dev/null || echo "apt")
YUM_CMD := $(shell command -v yum 2>/dev/null || echo "yum")
DNF_CMD := $(shell command -v dnf 2>/dev/null || echo "dnf")
CHOCO_CMD := $(shell command -v choco 2>/dev/null || echo "choco")

# Python environment tools
HAS_PYENV := $(shell command -v pyenv >/dev/null 2>&1 && echo "yes" || echo "no")
HAS_VENV := $(shell $(PYTHON_CMD) -m venv --help >/dev/null 2>&1 && echo "yes" || echo "no")

# Database tools
HAS_PSQL := $(shell command -v psql >/dev/null 2>&1 && echo "yes" || echo "no")
HAS_CREATEDB := $(shell command -v createdb >/dev/null 2>&1 && echo "yes" || echo "no")

# Quality tools (optional)
HAS_CHECKMAKE := $(shell command -v checkmake >/dev/null 2>&1 && echo "yes" || echo "no")
HAS_DOCKER := $(shell command -v docker >/dev/null 2>&1 && echo "yes" || echo "no")
HAS_ACT := $(shell command -v act >/dev/null 2>&1 && echo "yes" || echo "no")

# ============================================================================
# PLATFORM-SPECIFIC POSTGRESQL CONFIGURATION
# ============================================================================

ifeq ($(PLATFORM_OS),macos)
    # macOS PostgreSQL configuration (conditional assignment)
    PG_SERVICE_NAME ?= postgresql@15
    PG_DEFAULT_VERSION ?= 15
    PG_BIN_PATH ?= /opt/homebrew/bin
    ifeq ($(PLATFORM_ARCH),x64)
        PG_BIN_PATH ?= /usr/local/bin
    endif
    PG_START_CMD ?= $(SERVICE_START) $(PG_SERVICE_NAME)
    PG_STOP_CMD ?= $(SERVICE_STOP) $(PG_SERVICE_NAME)
    PG_STATUS_CMD ?= $(SERVICE_STATUS) | grep postgresql
else ifeq ($(PLATFORM_OS),linux)
    # Linux PostgreSQL configuration (conditional assignment)
    PG_SERVICE_NAME ?= postgresql
    PG_DEFAULT_VERSION ?= 14
    PG_BIN_PATH ?= /usr/bin
    PG_START_CMD ?= $(SERVICE_START) $(PG_SERVICE_NAME)
    PG_STOP_CMD ?= $(SERVICE_STOP) $(PG_SERVICE_NAME)
    PG_STATUS_CMD ?= $(SERVICE_STATUS) $(PG_SERVICE_NAME)
else
    # Windows PostgreSQL configuration (conditional assignment)
    PG_SERVICE_NAME ?= postgresql-x64-14
    PG_DEFAULT_VERSION ?= 14
    PG_BIN_PATH ?= C:\\Program Files\\PostgreSQL\\14\\bin
    PG_START_CMD ?= $(SERVICE_START) $(PG_SERVICE_NAME)
    PG_STOP_CMD ?= $(SERVICE_STOP) $(PG_SERVICE_NAME)
    PG_STATUS_CMD ?= $(SERVICE_STATUS) $(PG_SERVICE_NAME)
endif

# ============================================================================
# AIRFLOW PLATFORM CONFIGURATION
# ============================================================================

# Airflow platform configuration (conditional assignment)
ifeq ($(PLATFORM_FAMILY),unix)
    AIRFLOW_HOME_DEFAULT ?= $(shell pwd)/airflow
    AIRFLOW_DAGS_FOLDER_DEFAULT ?= $(shell pwd)/dags
    AIRFLOW_LOG_FOLDER_DEFAULT ?= $(shell pwd)/airflow/logs
else
    AIRFLOW_HOME_DEFAULT ?= $(shell cd)/airflow
    AIRFLOW_DAGS_FOLDER_DEFAULT ?= $(shell cd)/dags
    AIRFLOW_LOG_FOLDER_DEFAULT ?= $(shell cd)/airflow/logs
endif

# ============================================================================
# UTILITY FUNCTIONS FOR CROSS-PLATFORM OPERATIONS
# ============================================================================

# Function to check if a command exists
# Usage: $(call check_command,command_name)
define check_command
$(shell command -v $(1) >/dev/null 2>&1 && echo "yes" || echo "no")
endef

# Function to get absolute path (cross-platform)
# Usage: $(call abs_path,relative_path)
define abs_path
$(shell cd $(1) && pwd 2>/dev/null || echo $(1))
endef

# Function to create directory (cross-platform)
# Usage: $(call mkdir_p,directory_path)
ifeq ($(PLATFORM_FAMILY),unix)
define mkdir_p
mkdir -p $(1)
endef
else
define mkdir_p
if not exist "$(1)" mkdir "$(1)"
endef
endif

# Function to remove files/directories (cross-platform)
# Usage: $(call rm_rf,path)
ifeq ($(PLATFORM_FAMILY),unix)
define rm_rf
rm -rf $(1)
endef
else
define rm_rf
if exist "$(1)" rmdir /s /q "$(1)"
endef
endif

# ============================================================================
# PLATFORM INFORMATION AND DEBUGGING
# ============================================================================

.PHONY: platform-info platform-debug

platform-info: ## ℹ️ Display current platform detection information
	@printf "\033[0;36mPlatform Detection Results:\033[0m\n"
	@printf "\033[0;33mOperating System:\033[0m $(DETECTED_OS) ($(PLATFORM_OS))\n"
	@printf "\033[0;33mArchitecture:\033[0m $(DETECTED_ARCH) ($(PLATFORM_ARCH))\n"
	@printf "\033[0;33mPlatform Family:\033[0m $(PLATFORM_FAMILY)\n"
	@printf "\033[0;33mPackage Manager:\033[0m $(PACKAGE_MANAGER)\n"
	@printf "\033[0;33mService Manager:\033[0m $(SERVICE_MANAGER)\n"
	@printf "\033[0;33mPython Command:\033[0m $(PYTHON_CMD)\n"
	@printf "\033[0;33mShell:\033[0m $(SHELL)\n"

platform-debug: ## ℹ️ Display detailed platform detection and tool availability
	@printf "\033[0;36mPlatform Detection Debug Information:\033[0m\n"
	@printf "\033[0;33mRaw OS Detection:\033[0m $(DETECTED_OS)\n"
	@printf "\033[0;33mRaw Architecture:\033[0m $(DETECTED_ARCH)\n"
	@printf "\033[0;33mNormalized OS:\033[0m $(PLATFORM_OS)\n"
	@printf "\033[0;33mPlatform Family:\033[0m $(PLATFORM_FAMILY)\n"
	@echo ""
	@printf "\033[0;36mTool Availability:\033[0m\n"
	@printf "\033[0;33mPython ($(PYTHON_CMD)):\033[0m $(HAS_PYTHON)\n"
	@printf "\033[0;33mGit:\033[0m $(HAS_GIT)\n"
	@printf "\033[0;33mMake:\033[0m $(HAS_MAKE)\n"
	@printf "\033[0;33mpyenv:\033[0m $(HAS_PYENV)\n"
	@printf "\033[0;33mPostgreSQL (psql):\033[0m $(HAS_PSQL)\n"
	@printf "\033[0;33mPackage Manager ($(PACKAGE_MANAGER)):\033[0m $(call check_command,$(PACKAGE_MANAGER))\n"
	@echo ""
	@printf "\033[0;36mPlatform-Specific Configuration:\033[0m\n"
	@printf "\033[0;33mPostgreSQL Service:\033[0m $(PG_SERVICE_NAME)\n"
	@printf "\033[0;33mPostgreSQL Binary Path:\033[0m $(PG_BIN_PATH)\n"
	@printf "\033[0;33mAirflow Home:\033[0m $(AIRFLOW_HOME_DEFAULT)\n"

# Export platform variables for use in other modules
export PLATFORM_OS
export PLATFORM_FAMILY
export PLATFORM_ARCH
export PYTHON_CMD
export PIP_CMD
export BREW_CMD
export APT_CMD
export YUM_CMD
export DNF_CMD
export CHOCO_CMD
export PACKAGE_MANAGER
export SERVICE_MANAGER
export HAS_PYTHON
export HAS_PYENV
export HAS_BREW
export HAS_APT
export HAS_YUM
export HAS_DNF
export HAS_CHOCO

# ============================================================================
# PUBLIC PLATFORM TARGETS
# ============================================================================

.PHONY: show-platform-info

show-platform-info: ## 📋 Show detailed platform information (alias for platform-info)
	@$(MAKE) platform-info

# ============================================================================
# POSTGRESQL OPERATIONS AND DATA MANAGEMENT
# ============================================================================
# This module handles PostgreSQL database operations, including service
# management, database lifecycle, and data operations
#
# Dependencies: Makefile.platform, Makefile.env
# ============================================================================

# Database configuration from environment
DB_SERVICE_NAME = $(if $(filter $(PLATFORM_OS),macos),postgresql,postgresql)

# ============================================================================
# POSTGRESQL SERVICE MANAGEMENT
# ============================================================================

.PHONY: db-start db-stop db-restart db-status _start_postgres _stop_postgres

db-start: _load_env ## üóÑÔ∏è Start PostgreSQL service
	@printf "\033[0;34mStarting PostgreSQL service...\033[0m\n"
	@$(MAKE) _start_postgres
	@sleep 2
	@$(MAKE) db-status

db-stop: ## üóÑÔ∏è Stop PostgreSQL service
	@printf "\033[0;34mStopping PostgreSQL service...\033[0m\n"
	@$(MAKE) _stop_postgres
	@printf "\033[0;32m‚úì PostgreSQL service stopped\033[0m\n"

db-restart: ## üóÑÔ∏è Restart PostgreSQL service
	@printf "\033[0;34mRestarting PostgreSQL service...\033[0m\n"
	@$(MAKE) db-stop
	@sleep 1
	@$(MAKE) db-start

db-status: ## üóÑÔ∏è Validate PostgreSQL service status
	@printf "\033[0;36mPostgreSQL service status:\033[0m\n"
ifeq ($(PLATFORM_OS),macos)
	@if $(BREW_CMD) services list | grep -E "postgresql.*started" >/dev/null 2>&1; then \
		printf "\033[0;32m‚úì PostgreSQL is running (Homebrew)\033[0m\n"; \
		$(BREW_CMD) services list | grep postgresql; \
	else \
		printf "\033[0;33m‚ö† PostgreSQL is not running (Homebrew)\033[0m\n"; \
	fi
else ifeq ($(PLATFORM_OS),linux)
	@if systemctl is-active --quiet postgresql 2>/dev/null; then \
		printf "\033[0;32m‚úì PostgreSQL is running (systemd)\033[0m\n"; \
		systemctl status postgresql --no-pager -l; \
	elif service postgresql status >/dev/null 2>&1; then \
		printf "\033[0;32m‚úì PostgreSQL is running (service)\033[0m\n"; \
		service postgresql status; \
	else \
		printf "\033[0;33m‚ö† PostgreSQL is not running\033[0m\n"; \
	fi
else
	@if pgrep -f postgres >/dev/null 2>&1; then \
		printf "\033[0;32m‚úì PostgreSQL process found\033[0m\n"; \
		pgrep -f postgres; \
	else \
		printf "\033[0;33m‚ö† PostgreSQL process not found\033[0m\n"; \
	fi
endif

_start_postgres: ## Internal: Start PostgreSQL using platform-specific method
ifeq ($(PLATFORM_OS),macos)
	@if ! $(BREW_CMD) services list | grep -E "postgresql.*started" >/dev/null 2>&1; then \
		printf "\033[0;33mStarting PostgreSQL via Homebrew...\033[0m\n"; \
		$(BREW_CMD) services start postgresql || \
		$(BREW_CMD) services start postgresql@15 || \
		$(BREW_CMD) services start postgresql@14; \
		printf "\033[0;32m‚úì PostgreSQL started\033[0m\n"; \
	else \
		printf "\033[0;32m‚úì PostgreSQL already running\033[0m\n"; \
	fi
else ifeq ($(PLATFORM_OS),linux)
	@if ! systemctl is-active --quiet postgresql 2>/dev/null; then \
		printf "\033[0;33mStarting PostgreSQL via systemd...\033[0m\n"; \
		sudo systemctl start postgresql 2>/dev/null || \
		sudo service postgresql start 2>/dev/null; \
		printf "\033[0;32m‚úì PostgreSQL started\033[0m\n"; \
	else \
		printf "\033[0;32m‚úì PostgreSQL already running\033[0m\n"; \
	fi
else
	@printf "\033[0;33mManual PostgreSQL start may be required on this platform\033[0m\n"
	@printf "\033[0;36mCheck your PostgreSQL installation documentation\033[0m\n"
endif

_stop_postgres: ## Internal: Stop PostgreSQL using platform-specific method
ifeq ($(PLATFORM_OS),macos)
	@if $(BREW_CMD) services list | grep -E "postgresql.*started" >/dev/null 2>&1; then \
		printf "\033[0;33mStopping PostgreSQL via Homebrew...\033[0m\n"; \
		$(BREW_CMD) services stop postgresql || \
		$(BREW_CMD) services stop postgresql@15 || \
		$(BREW_CMD) services stop postgresql@14; \
	else \
		printf "\033[0;32m‚úì PostgreSQL already stopped\033[0m\n"; \
	fi
else ifeq ($(PLATFORM_OS),linux)
	@if systemctl is-active --quiet postgresql 2>/dev/null; then \
		printf "\033[0;33mStopping PostgreSQL via systemd...\033[0m\n"; \
		sudo systemctl stop postgresql 2>/dev/null || \
		sudo service postgresql stop 2>/dev/null; \
	else \
		printf "\033[0;32m‚úì PostgreSQL already stopped\033[0m\n"; \
	fi
else
	@printf "\033[0;33mManual PostgreSQL stop may be required on this platform\033[0m\n"
endif

# ============================================================================
# DATABASE LIFECYCLE MANAGEMENT
# ============================================================================

.PHONY: db-create db-drop db-reset db-exists _check_db_connection

db-create: _load_env db-start ## üóÑÔ∏è Create project database and user
	@printf "\033[0;34mCreating PostgreSQL database and user...\033[0m\n"
	@set -a && . ./.env && set +a && \
	printf "\033[0;33mDatabase Configuration:\033[0m\n" && \
	printf "\033[0;36m  Host: $$POSTGRES_HOST:$$POSTGRES_PORT\033[0m\n" && \
	printf "\033[0;36m  Database: $$POSTGRES_DB\033[0m\n" && \
	printf "\033[0;36m  User: $$POSTGRES_USER\033[0m\n" && \
	printf "\033[0;33mCreating PostgreSQL user...\033[0m\n" && \
	createuser -h $$POSTGRES_HOST -p $$POSTGRES_PORT -s $$POSTGRES_USER 2>/dev/null || \
	printf "\033[0;33m‚ö† User $$POSTGRES_USER already exists or creation failed\033[0m\n" && \
	printf "\033[0;33mCreating PostgreSQL database...\033[0m\n" && \
	createdb -h $$POSTGRES_HOST -p $$POSTGRES_PORT -O $$POSTGRES_USER $$POSTGRES_DB 2>/dev/null || \
	printf "\033[0;33m‚ö† Database $$POSTGRES_DB already exists or creation failed\033[0m\n" && \
	printf "\033[0;32m‚úì Database setup completed\033[0m\n"

db-drop: _load_env ## üóÑÔ∏è Drop project database (DESTRUCTIVE)
	@printf "\033[0;31mWARNING: This will permanently delete the database!\033[0m\n"
	@printf "\033[0;33mPress Ctrl+C to cancel, or Enter to continue...\033[0m\n"
	@read -p ""
	@set -a && . ./.env && set +a && \
	printf "\033[0;33mDropping database $$POSTGRES_DB...\033[0m\n" && \
	dropdb -h $$POSTGRES_HOST -p $$POSTGRES_PORT $$POSTGRES_DB 2>/dev/null || \
	printf "\033[0;33m‚ö† Database $$POSTGRES_DB does not exist or drop failed\033[0m\n" && \
	printf "\033[0;31m‚úì Database dropped\033[0m\n"

db-reset: db-drop db-create ## üóÑÔ∏è Drop and recreate database (DESTRUCTIVE)
	@printf "\033[0;32m‚úì Database reset completed\033[0m\n"

db-exists: _load_env ## üóÑÔ∏è Validate if project database exists
	@set -a && . ./.env && set +a && \
	if psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -lqt | cut -d \| -f 1 | grep -qw $$POSTGRES_DB; then \
		printf "\033[0;32m‚úì Database $$POSTGRES_DB exists\033[0m\n"; \
	else \
		printf "\033[0;33m‚ö† Database $$POSTGRES_DB does not exist\033[0m\n"; \
		exit 1; \
	fi

_check_db_connection: _load_env ## Internal: Test database connection
	@set -a && . ./.env && set +a && \
	printf "\033[0;33mTesting database connection...\033[0m\n" && \
	PGPASSWORD=$$POSTGRES_PASSWORD psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -d $$POSTGRES_DB -c "SELECT 1;" >/dev/null 2>&1 && \
	printf "\033[0;32m‚úì Database connection successful\033[0m\n" || \
	(printf "\033[0;31m‚ùå Database connection failed\033[0m\n" && exit 1)

# ============================================================================
# DATABASE SCHEMA AND MIGRATION MANAGEMENT
# ============================================================================

.PHONY: db-migrate db-schema db-init-schema _apply_ddl_files

db-migrate: _load_env db-exists ## üóÑÔ∏è Apply database migrations
	@printf "\033[0;34mApplying database migrations...\033[0m\n"
	@$(MAKE) _check_db_connection
	@$(MAKE) _apply_ddl_files
	@printf "\033[0;32m‚úì Database migrations completed\033[0m\n"

db-schema: _load_env db-exists ## üóÑÔ∏è Display database schema information
	@printf "\033[0;36mDatabase schema information:\033[0m\n"
	@set -a && . ./.env && set +a && \
	PGPASSWORD=$$POSTGRES_PASSWORD psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -d $$POSTGRES_DB -c "\dt" 2>/dev/null || \
	printf "\033[0;33m‚ö† No tables found or connection failed\033[0m\n"

db-init-schema: db-create _apply_ddl_files ## üóÑÔ∏è Initialize database with schema
	@printf "\033[0;32m‚úì Database schema initialization completed\033[0m\n"

_apply_ddl_files: _load_env ## Internal: Apply DDL files from dags/sql/ddl
	@set -a && . ./.env && set +a && \
	if [ -d "dags/sql/ddl" ]; then \
		printf "\033[0;33mApplying DDL files from dags/sql/ddl/...\033[0m\n"; \
		for ddl_file in dags/sql/ddl/*.sql; do \
			if [ -f "$$ddl_file" ]; then \
				printf "\033[0;36m  Executing: $$(basename $$ddl_file)\033[0m\n"; \
				PGPASSWORD=$$POSTGRES_PASSWORD psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -d $$POSTGRES_DB -f "$$ddl_file" 2>/dev/null || \
				printf "\033[0;33m  ‚ö† Warning: Failed to execute $$ddl_file\033[0m\n"; \
			fi; \
		done; \
	else \
		printf "\033[0;33m‚ö† No DDL directory found at dags/sql/ddl\033[0m\n"; \
		printf "\033[0;36mHint: Create DDL files in dags/sql/ddl/ for automatic schema setup\033[0m\n"; \
	fi

# ============================================================================
# DATA MANAGEMENT OPERATIONS
# ============================================================================

.PHONY: db-seed db-backup db-restore db-shell db-query

db-seed: _load_env db-exists ## üóÑÔ∏è Load initial data into database
	@printf "\033[0;34mLoading initial data...\033[0m\n"
	@$(MAKE) _check_db_connection
	@set -a && . ./.env && set +a && \
	if [ -d "dags/sql/data" ]; then \
		printf "\033[0;33mLoading data from dags/sql/data/...\033[0m\n"; \
		for data_file in dags/sql/data/*.sql; do \
			if [ -f "$$data_file" ]; then \
				printf "\033[0;36m  Loading: $$(basename $$data_file)\033[0m\n"; \
				PGPASSWORD=$$POSTGRES_PASSWORD psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -d $$POSTGRES_DB -f "$$data_file" 2>/dev/null || \
				printf "\033[0;33m  ‚ö† Warning: Failed to load $$data_file\033[0m\n"; \
			fi; \
		done; \
	else \
		printf "\033[0;33m‚ö† No data directory found at dags/sql/data\033[0m\n"; \
		printf "\033[0;36mHint: Create data files in dags/sql/data/ for automatic data loading\033[0m\n"; \
	fi
	@printf "\033[0;32m‚úì Data seeding completed\033[0m\n"

db-backup: _load_env db-exists ## üóÑÔ∏è Create database backup
	@printf "\033[0;34mCreating database backup...\033[0m\n"
	@$(MAKE) _check_db_connection
	@set -a && . ./.env && set +a && \
	backup_file="backup_$${POSTGRES_DB}_$$(date +%Y%m%d_%H%M%S).sql" && \
	printf "\033[0;33mCreating backup: $$backup_file\033[0m\n" && \
	PGPASSWORD=$$POSTGRES_PASSWORD pg_dump -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER $$POSTGRES_DB > $$backup_file && \
	printf "\033[0;32m‚úì Backup created: $$backup_file\033[0m\n"

db-restore: _load_env ## üóÑÔ∏è Restore database from backup file
	@printf "\033[0;34mRestoring database from backup...\033[0m\n"
	@printf "\033[0;33mAvailable backup files:\033[0m\n"
	@ls -la backup_*.sql 2>/dev/null || printf "\033[0;33mNo backup files found\033[0m\n"
	@printf "\033[0;33mEnter backup filename:\033[0m\n"
	@read -p "" backup_file && \
	if [ -f "$$backup_file" ]; then \
		printf "\033[0;31mWARNING: This will replace all data in the database!\033[0m\n"; \
		printf "\033[0;33mPress Ctrl+C to cancel, or Enter to continue...\033[0m\n"; \
		read -p ""; \
		$(MAKE) db-drop; \
		$(MAKE) db-create; \
		set -a && . ./.env && set +a && \
		printf "\033[0;33mRestoring from $$backup_file...\033[0m\n" && \
		PGPASSWORD=$$POSTGRES_PASSWORD psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -d $$POSTGRES_DB < $$backup_file && \
		printf "\033[0;32m‚úì Database restored from $$backup_file\033[0m\n"; \
	else \
		printf "\033[0;31m‚ùå Backup file not found: $$backup_file\033[0m\n"; \
	fi

db-shell: _load_env db-exists ## üóÑÔ∏è Open and display PostgreSQL shell (psql)
	@printf "\033[0;36mOpening PostgreSQL shell...\033[0m\n"
	@$(MAKE) _check_db_connection
	@set -a && . ./.env && set +a && \
	printf "\033[0;33mConnecting to $$POSTGRES_DB on $$POSTGRES_HOST:$$POSTGRES_PORT as $$POSTGRES_USER\033[0m\n" && \
	PGPASSWORD=$$POSTGRES_PASSWORD psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -d $$POSTGRES_DB

db-query: _load_env db-exists ## üóÑÔ∏è Execute a SQL query interactively
	@printf "\033[0;36mInteractive SQL query execution\033[0m\n"
	@$(MAKE) _check_db_connection
	@printf "\033[0;33mEnter your SQL query (end with semicolon):\033[0m\n"
	@read -p "SQL> " query && \
	set -a && . ./.env && set +a && \
	PGPASSWORD=$$POSTGRES_PASSWORD psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -d $$POSTGRES_DB -c "$$query"

# ============================================================================
# DATABASE MONITORING AND DIAGNOSTICS
# ============================================================================

.PHONY: db-info db-debug db-logs db-size db-connections

db-info: _load_env ## üóÑÔ∏è Display database information
	@printf "\033[0;36mDatabase Information:\033[0m\n"
	@set -a && . ./.env && set +a && \
	printf "\033[0;33mConfiguration:\033[0m\n" && \
	echo -e "  Host: $$POSTGRES_HOST:$$POSTGRES_PORT" && \
	echo -e "  Database: $$POSTGRES_DB" && \
	echo -e "  User: $$POSTGRES_USER" && \
	printf "\033[0;33mConnection Status:\033[0m\n" && \
	$(MAKE) _check_db_connection 2>/dev/null && \
	printf "\033[0;33mTables:\033[0m\n" && \
	PGPASSWORD=$$POSTGRES_PASSWORD psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -d $$POSTGRES_DB -c "\dt" 2>/dev/null || \
	printf "\033[0;33m  No tables found\033[0m\n"

db-debug: _load_env ## üóÑÔ∏è Debug and troubleshoot database connection and configuration
	@printf "\033[0;36mDatabase Debug Information:\033[0m\n"
	@set -a && . ./.env && set +a && \
	printf "\033[0;33mEnvironment Variables:\033[0m\n" && \
	echo -e "  POSTGRES_HOST=$$POSTGRES_HOST" && \
	echo -e "  POSTGRES_PORT=$$POSTGRES_PORT" && \
	echo -e "  POSTGRES_DB=$$POSTGRES_DB" && \
	echo -e "  POSTGRES_USER=$$POSTGRES_USER" && \
	echo -e "  POSTGRES_PASSWORD=$$(echo $$POSTGRES_PASSWORD | sed 's/./*/g')" && \
	printf "\033[0;33mPostgreSQL Service:\033[0m\n" && \
	$(MAKE) db-status && \
	printf "\033[0;33mConnection Test:\033[0m\n" && \
	$(MAKE) _check_db_connection || printf "\033[0;31mConnection failed\033[0m\n" && \
	printf "\033[0;33mDatabase Existence:\033[0m\n" && \
	$(MAKE) db-exists || printf "\033[0;31mDatabase does not exist\033[0m\n"

db-logs: ## üóÑÔ∏è View PostgreSQL logs
	@printf "\033[0;36mPostgreSQL logs:\033[0m\n"
ifeq ($(PLATFORM_OS),macos)
	@if [ -d "/opt/homebrew/var/log" ]; then \
		tail -n 50 /opt/homebrew/var/log/postgresql*.log 2>/dev/null || \
		printf "\033[0;33mPostgreSQL logs not found in /opt/homebrew/var/log\033[0m\n"; \
	elif [ -d "/usr/local/var/log" ]; then \
		tail -n 50 /usr/local/var/log/postgresql*.log 2>/dev/null || \
		printf "\033[0;33mPostgreSQL logs not found in /usr/local/var/log\033[0m\n"; \
	else \
		printf "\033[0;33mPostgreSQL log directory not found\033[0m\n"; \
	fi
else ifeq ($(PLATFORM_OS),linux)
	@sudo tail -n 50 /var/log/postgresql/postgresql*.log 2>/dev/null || \
	journalctl -u postgresql -n 50 --no-pager 2>/dev/null || \
	printf "\033[0;33mPostgreSQL logs not accessible\033[0m\n"
else
	@printf "\033[0;33mLog viewing not implemented for this platform\033[0m\n"
endif

db-size: _load_env db-exists ## üóÑÔ∏è Display database size information
	@printf "\033[0;36mDatabase size information:\033[0m\n"
	@$(MAKE) _check_db_connection
	@set -a && . ./.env && set +a && \
	PGPASSWORD=$$POSTGRES_PASSWORD psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -d $$POSTGRES_DB -c " \
	SELECT \
		schemaname, \
		tablename, \
		pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size \
	FROM pg_tables \
	WHERE schemaname = 'public' \
	ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;" 2>/dev/null || \
	printf "\033[0;33mUnable to retrieve size information\033[0m\n"

db-connections: _load_env db-exists ## üóÑÔ∏è Display active database connections
	@printf "\033[0;36mActive database connections:\033[0m\n"
	@$(MAKE) _check_db_connection
	@set -a && . ./.env && set +a && \
	PGPASSWORD=$$POSTGRES_PASSWORD psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -d $$POSTGRES_DB -c " \
	SELECT \
		pid, \
		usename, \
		application_name, \
		client_addr, \
		state, \
		query_start \
	FROM pg_stat_activity \
	WHERE datname = current_database();" 2>/dev/null || \
	printf "\033[0;33mUnable to retrieve connection information\033[0m\n"

# ============================================================================
# DATABASE CLEANUP OPERATIONS
# ============================================================================

.PHONY: db-clean-logs db-vacuum db-analyze

db-clean-logs: ## üóÑÔ∏è Clean PostgreSQL log files
	@printf "\033[0;33mCleaning PostgreSQL logs...\033[0m\n"
ifeq ($(PLATFORM_OS),macos)
	@find /opt/homebrew/var/log /usr/local/var/log -name "postgresql*.log" -type f -exec rm -f {} \; 2>/dev/null || \
	printf "\033[0;33mNo log files found or permission denied\033[0m\n"
else ifeq ($(PLATFORM_OS),linux)
	@sudo find /var/log/postgresql -name "postgresql*.log" -type f -exec rm -f {} \; 2>/dev/null || \
	printf "\033[0;33mNo log files found or permission denied\033[0m\n"
else
	@printf "\033[0;33mLog cleanup not implemented for this platform\033[0m\n"
endif
	@printf "\033[0;32m‚úì Log cleanup completed\033[0m\n"

db-vacuum: _load_env db-exists ## üóÑÔ∏è Vacuum database to reclaim space
	@printf "\033[0;34mRunning database vacuum...\033[0m\n"
	@$(MAKE) _check_db_connection
	@set -a && . ./.env && set +a && \
	PGPASSWORD=$$POSTGRES_PASSWORD psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -d $$POSTGRES_DB -c "VACUUM;" && \
	printf "\033[0;32m‚úì Database vacuum completed\033[0m\n"

db-analyze: _load_env db-exists ## üóÑÔ∏è Analyze database to update statistics
	@printf "\033[0;34mRunning database analyze...\033[0m\n"
	@$(MAKE) _check_db_connection
	@set -a && . ./.env && set +a && \
	PGPASSWORD=$$POSTGRES_PASSWORD psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -d $$POSTGRES_DB -c "ANALYZE;" && \
	printf "\033[0;32m‚úì Database analyze completed\033[0m\n"

# ============================================================================
# POSTGRESQL OPERATIONS AND DATA MANAGEMENT
# ============================================================================
# This module handles PostgreSQL database operations, including service
# management, database lifecycle, and data operations
#
# Dependencies: Makefile.platform, Makefile.env
# ============================================================================

# Database configuration from environment
DB_SERVICE_NAME = $(if $(filter $(PLATFORM_OS),macos),postgresql,postgresql)

# ============================================================================
# POSTGRESQL SERVICE MANAGEMENT
# ============================================================================

.PHONY: db-start db-stop db-restart db-status _start_postgres _stop_postgres

db-start: _load_env ## üóÑÔ∏è Start PostgreSQL service
	@$(ECHO_CMD) "$(BLUE)Starting PostgreSQL service...$(NC)\n"
	@$(MAKE) _start_postgres
	@sleep 2
	@$(MAKE) db-status

db-stop: ## üóÑÔ∏è Stop PostgreSQL service
	@$(ECHO_CMD) "$(BLUE)Stopping PostgreSQL service...$(NC)\n"
	@$(MAKE) _stop_postgres
	@$(ECHO_CMD) "$(GREEN)‚úì PostgreSQL service stopped$(NC)\n"

db-restart: ## üóÑÔ∏è Restart PostgreSQL service
	@$(ECHO_CMD) "$(BLUE)Restarting PostgreSQL service...$(NC)\n"
	@$(MAKE) db-stop
	@sleep 1
	@$(MAKE) db-start

db-status: ## üóÑÔ∏è Validate PostgreSQL service status
	@$(ECHO_CMD) "$(CYAN)PostgreSQL service status:$(NC)\n"
ifeq ($(PLATFORM_OS),macos)
	@if $(BREW_CMD) services list | grep -E "postgresql.*started" >/dev/null 2>&1; then \
		echo -e "$(GREEN)‚úì PostgreSQL is running (Homebrew)$(NC)"; \
		$(BREW_CMD) services list | grep postgresql; \
	else \
		echo -e "$(YELLOW)‚ö† PostgreSQL is not running (Homebrew)$(NC)"; \
	fi
else ifeq ($(PLATFORM_OS),linux)
	@if systemctl is-active --quiet postgresql 2>/dev/null; then \
		echo -e "$(GREEN)‚úì PostgreSQL is running (systemd)$(NC)"; \
		systemctl status postgresql --no-pager -l; \
	elif service postgresql status >/dev/null 2>&1; then \
		echo -e "$(GREEN)‚úì PostgreSQL is running (service)$(NC)"; \
		service postgresql status; \
	else \
		echo -e "$(YELLOW)‚ö† PostgreSQL is not running$(NC)"; \
	fi
else
	@if pgrep -f postgres >/dev/null 2>&1; then \
		echo -e "$(GREEN)‚úì PostgreSQL process found$(NC)"; \
		pgrep -f postgres; \
	else \
		echo -e "$(YELLOW)‚ö† PostgreSQL process not found$(NC)"; \
	fi
endif

_start_postgres: ## Internal: Start PostgreSQL using platform-specific method
ifeq ($(PLATFORM_OS),macos)
	@if ! $(BREW_CMD) services list | grep -E "postgresql.*started" >/dev/null 2>&1; then \
		echo -e "$(YELLOW)Starting PostgreSQL via Homebrew...$(NC)"; \
		$(BREW_CMD) services start postgresql || \
		$(BREW_CMD) services start postgresql@15 || \
		$(BREW_CMD) services start postgresql@14; \
		echo -e "$(GREEN)‚úì PostgreSQL started$(NC)"; \
	else \
		echo -e "$(GREEN)‚úì PostgreSQL already running$(NC)"; \
	fi
else ifeq ($(PLATFORM_OS),linux)
	@if ! systemctl is-active --quiet postgresql 2>/dev/null; then \
		echo -e "$(YELLOW)Starting PostgreSQL via systemd...$(NC)"; \
		sudo systemctl start postgresql 2>/dev/null || \
		sudo service postgresql start 2>/dev/null; \
		echo -e "$(GREEN)‚úì PostgreSQL started$(NC)"; \
	else \
		echo -e "$(GREEN)‚úì PostgreSQL already running$(NC)"; \
	fi
else
	@$(ECHO_CMD) "$(YELLOW)Manual PostgreSQL start may be required on this platform$(NC)\n"
	@$(ECHO_CMD) "$(CYAN)Check your PostgreSQL installation documentation$(NC)\n"
endif

_stop_postgres: ## Internal: Stop PostgreSQL using platform-specific method
ifeq ($(PLATFORM_OS),macos)
	@if $(BREW_CMD) services list | grep -E "postgresql.*started" >/dev/null 2>&1; then \
		echo -e "$(YELLOW)Stopping PostgreSQL via Homebrew...$(NC)"; \
		$(BREW_CMD) services stop postgresql || \
		$(BREW_CMD) services stop postgresql@15 || \
		$(BREW_CMD) services stop postgresql@14; \
	else \
		echo -e "$(GREEN)‚úì PostgreSQL already stopped$(NC)"; \
	fi
else ifeq ($(PLATFORM_OS),linux)
	@if systemctl is-active --quiet postgresql 2>/dev/null; then \
		echo -e "$(YELLOW)Stopping PostgreSQL via systemd...$(NC)"; \
		sudo systemctl stop postgresql 2>/dev/null || \
		sudo service postgresql stop 2>/dev/null; \
	else \
		echo -e "$(GREEN)‚úì PostgreSQL already stopped$(NC)"; \
	fi
else
	@$(ECHO_CMD) "$(YELLOW)Manual PostgreSQL stop may be required on this platform$(NC)\n"
endif

# ============================================================================
# DATABASE LIFECYCLE MANAGEMENT
# ============================================================================

.PHONY: db-create db-drop db-reset db-exists _check_db_connection

db-create: _load_env db-start ## üóÑÔ∏è Create project database and user
	@$(ECHO_CMD) "$(BLUE)Creating PostgreSQL database and user...$(NC)\n"
	@set -a && . ./.env && set +a && \
	echo -e "$(YELLOW)Database Configuration:$(NC)" && \
	echo -e "$(CYAN)  Host: $$POSTGRES_HOST:$$POSTGRES_PORT$(NC)" && \
	echo -e "$(CYAN)  Database: $$POSTGRES_DB$(NC)" && \
	echo -e "$(CYAN)  User: $$POSTGRES_USER$(NC)" && \
	echo -e "$(YELLOW)Creating PostgreSQL user...$(NC)" && \
	createuser -h $$POSTGRES_HOST -p $$POSTGRES_PORT -s $$POSTGRES_USER 2>/dev/null || \
	echo -e "$(YELLOW)‚ö† User $$POSTGRES_USER already exists or creation failed$(NC)" && \
	echo -e "$(YELLOW)Creating PostgreSQL database...$(NC)" && \
	createdb -h $$POSTGRES_HOST -p $$POSTGRES_PORT -O $$POSTGRES_USER $$POSTGRES_DB 2>/dev/null || \
	echo -e "$(YELLOW)‚ö† Database $$POSTGRES_DB already exists or creation failed$(NC)" && \
	echo -e "$(GREEN)‚úì Database setup completed$(NC)"

db-drop: _load_env ## üóÑÔ∏è Drop project database (DESTRUCTIVE)
	@$(ECHO_CMD) "$(RED)WARNING: This will permanently delete the database!$(NC)\n"
	@$(ECHO_CMD) "$(YELLOW)Press Ctrl+C to cancel, or Enter to continue...$(NC)\n"
	@read -p ""
	@set -a && . ./.env && set +a && \
	echo -e "$(YELLOW)Dropping database $$POSTGRES_DB...$(NC)" && \
	dropdb -h $$POSTGRES_HOST -p $$POSTGRES_PORT $$POSTGRES_DB 2>/dev/null || \
	echo -e "$(YELLOW)‚ö† Database $$POSTGRES_DB does not exist or drop failed$(NC)" && \
	echo -e "$(RED)‚úì Database dropped$(NC)"

db-reset: db-drop db-create ## üóÑÔ∏è Drop and recreate database (DESTRUCTIVE)
	@$(ECHO_CMD) "$(GREEN)‚úì Database reset completed$(NC)\n"

db-exists: _load_env ## üóÑÔ∏è Validate if project database exists
	@set -a && . ./.env && set +a && \
	if psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -lqt | cut -d \| -f 1 | grep -qw $$POSTGRES_DB; then \
		echo -e "$(GREEN)‚úì Database $$POSTGRES_DB exists$(NC)"; \
	else \
		echo -e "$(YELLOW)‚ö† Database $$POSTGRES_DB does not exist$(NC)"; \
		exit 1; \
	fi

_check_db_connection: _load_env ## Internal: Test database connection
	@set -a && . ./.env && set +a && \
	echo -e "$(YELLOW)Testing database connection...$(NC)" && \
	PGPASSWORD=$$POSTGRES_PASSWORD psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -d $$POSTGRES_DB -c "SELECT 1;" >/dev/null 2>&1 && \
	echo -e "$(GREEN)‚úì Database connection successful$(NC)" || \
	(echo -e "$(RED)‚ùå Database connection failed$(NC)" && exit 1)

# ============================================================================
# DATABASE SCHEMA AND MIGRATION MANAGEMENT
# ============================================================================

.PHONY: db-migrate db-schema db-init-schema _apply_ddl_files

db-migrate: _load_env db-exists ## üóÑÔ∏è Apply database migrations
	@$(ECHO_CMD) "$(BLUE)Applying database migrations...$(NC)\n"
	@$(MAKE) _check_db_connection
	@$(MAKE) _apply_ddl_files
	@$(ECHO_CMD) "$(GREEN)‚úì Database migrations completed$(NC)\n"

db-schema: _load_env db-exists ## üóÑÔ∏è Display database schema information
	@$(ECHO_CMD) "$(CYAN)Database schema information:$(NC)\n"
	@set -a && . ./.env && set +a && \
	PGPASSWORD=$$POSTGRES_PASSWORD psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -d $$POSTGRES_DB -c "\dt" 2>/dev/null || \
	echo -e "$(YELLOW)‚ö† No tables found or connection failed$(NC)"

db-init-schema: db-create _apply_ddl_files ## üóÑÔ∏è Initialize database with schema
	@$(ECHO_CMD) "$(GREEN)‚úì Database schema initialization completed$(NC)\n"

_apply_ddl_files: _load_env ## Internal: Apply DDL files from dags/sql/ddl
	@set -a && . ./.env && set +a && \
	if [ -d "dags/sql/ddl" ]; then \
		echo -e "$(YELLOW)Applying DDL files from dags/sql/ddl/...$(NC)"; \
		for ddl_file in dags/sql/ddl/*.sql; do \
			if [ -f "$$ddl_file" ]; then \
				echo -e "$(CYAN)  Executing: $$(basename $$ddl_file)$(NC)"; \
				PGPASSWORD=$$POSTGRES_PASSWORD psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -d $$POSTGRES_DB -f "$$ddl_file" 2>/dev/null || \
				echo -e "$(YELLOW)  ‚ö† Warning: Failed to execute $$ddl_file$(NC)"; \
			fi; \
		done; \
	else \
		echo -e "$(YELLOW)‚ö† No DDL directory found at dags/sql/ddl$(NC)"; \
		echo -e "$(CYAN)Hint: Create DDL files in dags/sql/ddl/ for automatic schema setup$(NC)"; \
	fi

# ============================================================================
# DATA MANAGEMENT OPERATIONS
# ============================================================================

.PHONY: db-seed db-backup db-restore db-shell db-query

db-seed: _load_env db-exists ## üóÑÔ∏è Load initial data into database
	@$(ECHO_CMD) "$(BLUE)Loading initial data...$(NC)\n"
	@$(MAKE) _check_db_connection
	@set -a && . ./.env && set +a && \
	if [ -d "dags/sql/data" ]; then \
		echo -e "$(YELLOW)Loading data from dags/sql/data/...$(NC)"; \
		for data_file in dags/sql/data/*.sql; do \
			if [ -f "$$data_file" ]; then \
				echo -e "$(CYAN)  Loading: $$(basename $$data_file)$(NC)"; \
				PGPASSWORD=$$POSTGRES_PASSWORD psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -d $$POSTGRES_DB -f "$$data_file" 2>/dev/null || \
				echo -e "$(YELLOW)  ‚ö† Warning: Failed to load $$data_file$(NC)"; \
			fi; \
		done; \
	else \
		echo -e "$(YELLOW)‚ö† No data directory found at dags/sql/data$(NC)"; \
		echo -e "$(CYAN)Hint: Create data files in dags/sql/data/ for automatic data loading$(NC)"; \
	fi
	@$(ECHO_CMD) "$(GREEN)‚úì Data seeding completed$(NC)\n"

db-backup: _load_env db-exists ## üóÑÔ∏è Create database backup
	@$(ECHO_CMD) "$(BLUE)Creating database backup...$(NC)\n"
	@$(MAKE) _check_db_connection
	@set -a && . ./.env && set +a && \
	backup_file="backup_$${POSTGRES_DB}_$$(date +%Y%m%d_%H%M%S).sql" && \
	echo -e "$(YELLOW)Creating backup: $$backup_file$(NC)" && \
	PGPASSWORD=$$POSTGRES_PASSWORD pg_dump -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER $$POSTGRES_DB > $$backup_file && \
	echo -e "$(GREEN)‚úì Backup created: $$backup_file$(NC)"

db-restore: _load_env ## üóÑÔ∏è Restore database from backup file
	@$(ECHO_CMD) "$(BLUE)Restoring database from backup...$(NC)\n"
	@$(ECHO_CMD) "$(YELLOW)Available backup files:$(NC)\n"
	@ls -la backup_*.sql 2>/dev/null || echo -e "$(YELLOW)No backup files found$(NC)"
	@$(ECHO_CMD) "$(YELLOW)Enter backup filename:$(NC)\n"
	@read -p "" backup_file && \
	if [ -f "$$backup_file" ]; then \
		echo -e "$(RED)WARNING: This will replace all data in the database!$(NC)"; \
		echo -e "$(YELLOW)Press Ctrl+C to cancel, or Enter to continue...$(NC)"; \
		read -p ""; \
		$(MAKE) db-drop; \
		$(MAKE) db-create; \
		set -a && . ./.env && set +a && \
		echo -e "$(YELLOW)Restoring from $$backup_file...$(NC)" && \
		PGPASSWORD=$$POSTGRES_PASSWORD psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -d $$POSTGRES_DB < $$backup_file && \
		echo -e "$(GREEN)‚úì Database restored from $$backup_file$(NC)"; \
	else \
		echo -e "$(RED)‚ùå Backup file not found: $$backup_file$(NC)"; \
	fi

db-shell: _load_env db-exists ## üóÑÔ∏è Open and display PostgreSQL shell (psql)
	@$(ECHO_CMD) "$(CYAN)Opening PostgreSQL shell...$(NC)\n"
	@$(MAKE) _check_db_connection
	@set -a && . ./.env && set +a && \
	echo -e "$(YELLOW)Connecting to $$POSTGRES_DB on $$POSTGRES_HOST:$$POSTGRES_PORT as $$POSTGRES_USER$(NC)" && \
	PGPASSWORD=$$POSTGRES_PASSWORD psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -d $$POSTGRES_DB

db-query: _load_env db-exists ## üóÑÔ∏è Execute a SQL query interactively
	@$(ECHO_CMD) "$(CYAN)Interactive SQL query execution$(NC)\n"
	@$(MAKE) _check_db_connection
	@$(ECHO_CMD) "$(YELLOW)Enter your SQL query (end with semicolon):$(NC)\n"
	@read -p "SQL> " query && \
	set -a && . ./.env && set +a && \
	PGPASSWORD=$$POSTGRES_PASSWORD psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -d $$POSTGRES_DB -c "$$query"

# ============================================================================
# DATABASE MONITORING AND DIAGNOSTICS
# ============================================================================

.PHONY: db-info db-debug db-logs db-size db-connections

db-info: _load_env ## üóÑÔ∏è Display database information
	@$(ECHO_CMD) "$(CYAN)Database Information:$(NC)\n"
	@set -a && . ./.env && set +a && \
	echo -e "$(YELLOW)Configuration:$(NC)" && \
	echo -e "  Host: $$POSTGRES_HOST:$$POSTGRES_PORT" && \
	echo -e "  Database: $$POSTGRES_DB" && \
	echo -e "  User: $$POSTGRES_USER" && \
	echo -e "$(YELLOW)Connection Status:$(NC)" && \
	$(MAKE) _check_db_connection 2>/dev/null && \
	echo -e "$(YELLOW)Tables:$(NC)" && \
	PGPASSWORD=$$POSTGRES_PASSWORD psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -d $$POSTGRES_DB -c "\dt" 2>/dev/null || \
	echo -e "$(YELLOW)  No tables found$(NC)"

db-debug: _load_env ## üóÑÔ∏è Debug and troubleshoot database connection and configuration
	@$(ECHO_CMD) "$(CYAN)Database Debug Information:$(NC)\n"
	@set -a && . ./.env && set +a && \
	echo -e "$(YELLOW)Environment Variables:$(NC)" && \
	echo -e "  POSTGRES_HOST=$$POSTGRES_HOST" && \
	echo -e "  POSTGRES_PORT=$$POSTGRES_PORT" && \
	echo -e "  POSTGRES_DB=$$POSTGRES_DB" && \
	echo -e "  POSTGRES_USER=$$POSTGRES_USER" && \
	echo -e "  POSTGRES_PASSWORD=$$(echo $$POSTGRES_PASSWORD | sed 's/./*/g')" && \
	echo -e "$(YELLOW)PostgreSQL Service:$(NC)" && \
	$(MAKE) db-status && \
	echo -e "$(YELLOW)Connection Test:$(NC)" && \
	$(MAKE) _check_db_connection || echo -e "$(RED)Connection failed$(NC)" && \
	echo -e "$(YELLOW)Database Existence:$(NC)" && \
	$(MAKE) db-exists || echo -e "$(RED)Database does not exist$(NC)"

db-logs: ## üóÑÔ∏è View PostgreSQL logs
	@$(ECHO_CMD) "$(CYAN)PostgreSQL logs:$(NC)\n"
ifeq ($(PLATFORM_OS),macos)
	@if [ -d "/opt/homebrew/var/log" ]; then \
		tail -n 50 /opt/homebrew/var/log/postgresql*.log 2>/dev/null || \
		echo -e "$(YELLOW)PostgreSQL logs not found in /opt/homebrew/var/log$(NC)"; \
	elif [ -d "/usr/local/var/log" ]; then \
		tail -n 50 /usr/local/var/log/postgresql*.log 2>/dev/null || \
		echo -e "$(YELLOW)PostgreSQL logs not found in /usr/local/var/log$(NC)"; \
	else \
		echo -e "$(YELLOW)PostgreSQL log directory not found$(NC)"; \
	fi
else ifeq ($(PLATFORM_OS),linux)
	@sudo tail -n 50 /var/log/postgresql/postgresql*.log 2>/dev/null || \
	journalctl -u postgresql -n 50 --no-pager 2>/dev/null || \
	echo -e "$(YELLOW)PostgreSQL logs not accessible$(NC)"
else
	@$(ECHO_CMD) "$(YELLOW)Log viewing not implemented for this platform$(NC)\n"
endif

db-size: _load_env db-exists ## üóÑÔ∏è Display database size information
	@$(ECHO_CMD) "$(CYAN)Database size information:$(NC)\n"
	@$(MAKE) _check_db_connection
	@set -a && . ./.env && set +a && \
	PGPASSWORD=$$POSTGRES_PASSWORD psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -d $$POSTGRES_DB -c "\
	SELECT \
		schemaname, \
		tablename, \
		pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size \
	FROM pg_tables \
	WHERE schemaname = 'public' \
	ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;" 2>/dev/null || \
	echo -e "$(YELLOW)Unable to retrieve size information$(NC)"

db-connections: _load_env db-exists ## üóÑÔ∏è Display active database connections
	@$(ECHO_CMD) "$(CYAN)Active database connections:$(NC)\n"
	@$(MAKE) _check_db_connection
	@set -a && . ./.env && set +a && \
	PGPASSWORD=$$POSTGRES_PASSWORD psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -d $$POSTGRES_DB -c "\
	SELECT \
		pid, \
		usename, \
		application_name, \
		client_addr, \
		state, \
		query_start \
	FROM pg_stat_activity \
	WHERE datname = current_database();" 2>/dev/null || \
	echo -e "$(YELLOW)Unable to retrieve connection information$(NC)"

# ============================================================================
# DATABASE CLEANUP OPERATIONS
# ============================================================================

.PHONY: db-clean-logs db-vacuum db-analyze

db-clean-logs: ## üóÑÔ∏è Clean PostgreSQL log files
	@$(ECHO_CMD) "$(YELLOW)Cleaning PostgreSQL logs...$(NC)\n"
ifeq ($(PLATFORM_OS),macos)
	@find /opt/homebrew/var/log /usr/local/var/log -name "postgresql*.log" -type f -exec rm -f {} \; 2>/dev/null || \
	echo -e "$(YELLOW)No log files found or permission denied$(NC)"
else ifeq ($(PLATFORM_OS),linux)
	@sudo find /var/log/postgresql -name "postgresql*.log" -type f -exec rm -f {} \; 2>/dev/null || \
	echo -e "$(YELLOW)No log files found or permission denied$(NC)"
else
	@$(ECHO_CMD) "$(YELLOW)Log cleanup not implemented for this platform$(NC)\n"
endif
	@$(ECHO_CMD) "$(GREEN)‚úì Log cleanup completed$(NC)\n"

db-vacuum: _load_env db-exists ## üóÑÔ∏è Vacuum database to reclaim space
	@$(ECHO_CMD) "$(BLUE)Running database vacuum...$(NC)\n"
	@$(MAKE) _check_db_connection
	@set -a && . ./.env && set +a && \
	PGPASSWORD=$$POSTGRES_PASSWORD psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -d $$POSTGRES_DB -c "VACUUM;" && \
	echo -e "$(GREEN)‚úì Database vacuum completed$(NC)"

db-analyze: _load_env db-exists ## üóÑÔ∏è Analyze database to update statistics
	@$(ECHO_CMD) "$(BLUE)Running database analyze...$(NC)\n"
	@$(MAKE) _check_db_connection
	@set -a && . ./.env && set +a && \
	PGPASSWORD=$$POSTGRES_PASSWORD psql -h $$POSTGRES_HOST -p $$POSTGRES_PORT -U $$POSTGRES_USER -d $$POSTGRES_DB -c "ANALYZE;" && \
	echo -e "$(GREEN)‚úì Database analyze completed$(NC)"
